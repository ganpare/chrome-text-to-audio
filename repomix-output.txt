This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-05T09:29:01.142Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
.replit
attached_assets/Pasted-Created-new-AudioDatabase-instance-contentScript-js-7-AudioDatabase-instance-created-successfully-lo-1743482242381.txt
attached_assets/Pasted-Initializing-AudioDatabase-dbHelper-js-18-Created-new-AudioDatabase-instance-contentScript-js-7-A-1743830299943.txt
attached_assets/Pasted-Manual-refresh-requested-dbHelper-js-73-Opening-database-connection-dbHelper-js-106-Existing-data-1743831360905.txt
attached_assets/Pasted-Opening-database-connection-dbHelper-js-106-Existing-database-connection-is-valid-options-js-213--1743839814110.txt
attached_assets/Pasted-options-js-442-Error-in-loadAudioList-TypeError-Assignment-to-constant-variable-at-loadAudioL-1743831115258.txt
attached_assets/Pasted-Received-playAudio-message-action-playAudio-url-https-fal-media-files-tiger-gy-C1T-fTR8s4G-1743337088354.txt
background.js
code_summary.md
contentScript.js
dbHelper.js
dependencies.md
history.html
history.js
LICENSE
manifest.json
options.html
options.js
README.md
styles.css

================================================================
Files
================================================================

================
File: .gitignore
================
# Node.js dependencies
node_modules/

# IDE and editor files
.vscode/
.idea/
*.swp
*.swo

# OS generated files
.DS_Store
Thumbs.db

# Chrome extension specific
*.crx
*.pem

# Build output
dist/
build/

================
File: .replit
================
modules = ["nodejs-20", "web"]

[nix]
channel = "stable-24_05"

================
File: attached_assets/Pasted-Created-new-AudioDatabase-instance-contentScript-js-7-AudioDatabase-instance-created-successfully-lo-1743482242381.txt
================
Created new AudioDatabase instance
contentScript.js:7 AudioDatabase instance created successfully
lockdown-install.js:1 Removing unpermitted intrinsics
dbHelper.js:53 Database initialized successfully
installation:1 Unchecked runtime.lastError: Could not establish connection. Receiving end does not exist.Understand this errorAI
18Unchecked runtime.lastError: A listener indicated an asynchronous response by returning true, but the message channel closed before a response was receivedUnderstand this errorAI
installation:1 The resource https://nextjs.org/_next/static/css/4e76815e609c056f.css?dpl=dpl_9ANsQYsKRpEcJVy1c481w1N1s9Nx was preloaded using link preload but not used within a few seconds from the window's load event. Please make sure it has an appropriate `as` value and it is preloaded intentionally.Understand this warningAI
contentScript.js:55 Received playAudio message: Object
contentScript.js:76 Preparing audio for playback...
contentScript.js:89 Audio is ready to play
contentScript.js:93 Starting audio playback...
contentScript.js:112 Audio playback ended
contentScript.js:152 音声再生完了、データベースに保存を開始します
dbHelper.js:146 Saving audio to database...
dbHelper.js:152 Saving audio: duration=0.33s, size=57644bytes
dbHelper.js:73 Opening database connection...
dbHelper.js:91 Existing database connection is valid
dbHelper.js:181 Saving audio record to database...
dbHelper.js:188 Audio saved successfully with ID: 6
dbHelper.js:198 Transaction completed successfully
contentScript.js:155 Audio saved successfully with ID: 6
contentScript.js:161 Sending refresh message to options page
contentScript.js:171 Refresh options page response: {success: false, error: 'No active pages found'}
installation:1 The resource https://nextjs.org/_next/static/css/4e76815e609c056f.css?dpl=dpl_9ANsQYsKRpEcJVy1c481w1N1s9Nx was preloaded using link preload but not used within a few seconds from the window's load event. Please make sure it has an appropriate `as` value and it is preloaded intentionally.Understand this warningAI
installation:1 The resource https://nextjs.org/_next/static/css/4e76815e609c056f.css?dpl=dpl_9ANsQYsKRpEcJVy1c481w1N1s9Nx was preloaded using link preload but not used within a few seconds from the window's load event. Please make sure it has an appropriate `as` value and it is preloaded intentionally.

================
File: attached_assets/Pasted-Initializing-AudioDatabase-dbHelper-js-18-Created-new-AudioDatabase-instance-contentScript-js-7-A-1743830299943.txt
================
Initializing AudioDatabase...
dbHelper.js:18 Created new AudioDatabase instance
contentScript.js:7 AudioDatabase instance created successfully
lockdown-install.js:1 Removing unpermitted intrinsics
6Refused to load the font '<URL>' because it violates the following Content Security Policy directive: "font-src github.githubassets.com".
Understand this errorAI
dbHelper.js:53 Database initialized successfully
/neelabo/NeeView?tab=readme-ov-file:1 Unchecked runtime.lastError: Could not establish connection. Receiving end does not exist.Understand this errorAI
/neelabo/NeeView?tab=readme-ov-file:1 Error in event handler: TypeError: Cannot read properties of null (reading 'tagName')
    at Readability._grabArticle (chrome-extension://llimhhconnjiflfimocjggfjdlmlhblm/js/plugins/readability.js:1140:37)
    at Readability.parse (chrome-extension://llimhhconnjiflfimocjggfjdlmlhblm/js/plugins/readability.js:2248:31)
    at Object.original_article (chrome-extension://llimhhconnjiflfimocjggfjdlmlhblm/content-script.js:94:61)
    at Object.article (chrome-extension://llimhhconnjiflfimocjggfjdlmlhblm/content-script.js:148:44)
    at Object.article (chrome-extension://llimhhconnjiflfimocjggfjdlmlhblm/content-script.js:198:23)
    at Object.init (chrome-extension://llimhhconnjiflfimocjggfjdlmlhblm/content-script.js:570:19)
    at chrome-extension://llimhhconnjiflfimocjggfjdlmlhblm/content-script.js:514:23Understand this errorAI
releases:1 Error in event handler: TypeError: Cannot read properties of null (reading 'tagName')
    at Readability._grabArticle (chrome-extension://llimhhconnjiflfimocjggfjdlmlhblm/js/plugins/readability.js:1140:37)
    at Readability.parse (chrome-extension://llimhhconnjiflfimocjggfjdlmlhblm/js/plugins/readability.js:2248:31)
    at Object.original_article (chrome-extension://llimhhconnjiflfimocjggfjdlmlhblm/content-script.js:94:61)
    at Object.article (chrome-extension://llimhhconnjiflfimocjggfjdlmlhblm/content-script.js:148:44)
    at Object.article (chrome-extension://llimhhconnjiflfimocjggfjdlmlhblm/content-script.js:198:23)
    at Object.init (chrome-extension://llimhhconnjiflfimocjggfjdlmlhblm/content-script.js:570:19)
    at chrome-extension://llimhhconnjiflfimocjggfjdlmlhblm/content-script.js:514:23Understand this errorAI
12Unchecked runtime.lastError: A listener indicated an asynchronous response by returning true, but the message channel closed before a response was receivedUnderstand this errorAI
contentScript.js:63 Received playAudio message: Object
contentScript.js:84 Preparing audio for playback...
releases:1 Refused to load media from 'blob:https://github.com/27e313f8-7317-46a3-be0d-b2f8b8f23047' because it violates the following Content Security Policy directive: "media-src github.com user-images.githubusercontent.com/ secured-user-images.githubusercontent.com/ private-user-images.githubusercontent.com github-production-user-asset-6210df.s3.amazonaws.com gist.github.com".
Understand this errorAI
contentScript.js:127 Audio playback error: Event
audio.onerror @ contentScript.js:127Understand this errorAI
contentScript.js:197 Error in playAudio: Event
(anonymous) @ contentScript.js:197Understand this errorAI
releases:1 Refused to load the stylesheet 'https://fonts.googleapis.com/css?family=Open+Sans:300,400,600' because it violates the following Content Security Policy directive: "style-src 'unsafe-inline' github.githubassets.com". Note that 'style-src-elem' was not explicitly set, so 'style-src' is used as a fallback.
Understand this errorAI
contentScript.js:140 Audio playback timeout

================
File: attached_assets/Pasted-Manual-refresh-requested-dbHelper-js-73-Opening-database-connection-dbHelper-js-106-Existing-data-1743831360905.txt
================
Manual refresh requested
dbHelper.js:73 Opening database connection...
dbHelper.js:106 Existing database connection is valid
options.js:182 loadAudioList called with query: 
dbHelper.js:73 Opening database connection...
dbHelper.js:106 Existing database connection is valid
dbHelper.js:287 Database state: {isOpen: true, objectStoreExists: true, recordCount: 0, dbName: 'kokoroTts', dbVersion: 1}dbName: "kokoroTts"dbVersion: 1isOpen: trueobjectStoreExists: truerecordCount: 0[[Prototype]]: Object
options.js:194 Current database state: {isOpen: true, objectStoreExists: true, recordCount: 0, dbName: 'kokoroTts', dbVersion: 1}
options.js:442 Error in loadAudioList: TypeError: Assignment to constant variable.
    at loadAudioList (options.js:204:10)
    at async HTMLButtonElement.<anonymous> (options.js:105:9)
loadAudioList @ options.js:442
await in loadAudioList
(anonymous) @ options.js:105Understand this errorAI
options.js:154 Refreshing audio list...
options.js:182 loadAudioList called with query: 
dbHelper.js:73 Opening database connection...
dbHelper.js:106 Existing database connection is valid
dbHelper.js:287 Database state: {isOpen: true, objectStoreExists: true, recordCount: 0, dbName: 'kokoroTts', dbVersion: 1}
options.js:194 Current database state: {isOpen: true, objectStoreExists: true, recordCount: 0, dbName: 'kokoroTts', dbVersion: 1}
options.js:442 Error in loadAudioList: TypeError: Assignment to constant variable.
    at loadAudioList (options.js:204:10)
    at async options.js:155:7
loadAudioList @ options.js:442
await in loadAudioList
(anonymous) @ options.js:155Understand this errorAI
options.js:154 Refreshing audio list...
options.js:182 loadAudioList called with query: 
dbHelper.js:73 Opening database connection...
dbHelper.js:106 Existing database connection is valid
dbHelper.js:287 Database state: {isOpen: true, objectStoreExists: true, recordCount: 0, dbName: 'kokoroTts', dbVersion: 1}
options.js:194 Current database state: {isOpen: true, objectStoreExists: true, recordCount: 0, dbName: 'kokoroTts', dbVersion: 1}
options.js:442 Error in loadAudioList: TypeError: Assignment to constant variable.
    at loadAudioList (options.js:204:10)
    at async options.js:155:7

================
File: attached_assets/Pasted-Opening-database-connection-dbHelper-js-106-Existing-database-connection-is-valid-options-js-213--1743839814110.txt
================
Opening database connection...
dbHelper.js:106 Existing database connection is valid
options.js:213 Getting audio list (attempt 2/3)...
dbHelper.js:324 getAudioList called
dbHelper.js:73 Opening database connection...
dbHelper.js:106 Existing database connection is valid
dbHelper.js:287 Database state: Object
dbHelper.js:328 Database state before getAudioList: Object
dbHelper.js:73 Opening database connection...
dbHelper.js:78 Force reopening database connection
dbHelper.js:91 Waiting for database initialization...
dbHelper.js:121 Creating new database connection (attempt 1/3)
dbHelper.js:287 Database state: Object
dbHelper.js:328 Database state before getAudioList: Object
dbHelper.js:73 Opening database connection...
dbHelper.js:91 Waiting for database initialization...
dbHelper.js:121 Creating new database connection (attempt 1/3)
dbHelper.js:160 Database connection established successfully
dbHelper.js:339 Starting transaction for getAudioList (attempt 1/3)
dbHelper.js:160 Database connection established successfully
dbHelper.js:339 Starting transaction for getAudioList (attempt 1/3)
dbHelper.js:369 Raw database results (attempt 1): 0 items found
dbHelper.js:381 Processed audio files (attempt 1): 0 items
dbHelper.js:385 Number of audio files with blob data: 0/0
options.js:215 Attempt 3: Retrieved audio files: 0 items
options.js:270 Filtered audio files: 0 items
options.js:273 No audio files found after filtering
options.js:419 Error in loadAudioList: ReferenceError: setupForceRefreshButton is not defined
    at loadAudioList (options.js:286:9)
    at async options.js:26:9
loadAudioList @ options.js:419Understand this errorAI
options.js:30 Error in delayed refresh: ReferenceError: setupForceRefreshButton is not defined
    at loadAudioList (options.js:432:7)
    at async options.js:26:9
(anonymous) @ options.js:30Understand this errorAI
dbHelper.js:369 Raw database results (attempt 1): 0 items found
dbHelper.js:381 Processed audio files (attempt 1): 0 items
dbHelper.js:385 Number of audio files with blob data: 0/0
options.js:215 Attempt 2: Retrieved audio files: 0 items
options.js:223 No audio files found, waiting before next attempt...
2dbHelper.js:357 Transaction completed successfully
options.js:213 Getting audio list (attempt 3/3)...
dbHelper.js:324 getAudioList called
dbHelper.js:73 Opening database connection...
dbHelper.js:106 Existing database connection is valid
dbHelper.js:287 Database state: Object
dbHelper.js:328 Database state before getAudioList: Object
dbHelper.js:73 Opening database connection...
dbHelper.js:78 Force reopening database connection
dbHelper.js:91 Waiting for database initialization...
dbHelper.js:121 Creating new database connection (attempt 1/3)
dbHelper.js:160 Database connection established successfully
dbHelper.js:339 Starting transaction for getAudioList (attempt 1/3)
dbHelper.js:369 Raw database results (attempt 1): 0 items found
dbHelper.js:381 Processed audio files (attempt 1): 0 items
dbHelper.js:385 Number of audio files with blob data: 0/0
options.js:215 Attempt 3: Retrieved audio files: 0 items
options.js:270 Filtered audio files: 0 items
options.js:273 No audio files found after filtering
options.js:419 Error in loadAudioList: ReferenceError: setupForceRefreshButton is not defined
    at loadAudioList (options.js:286:9)
    at async options.js:26:9
loadAudioList @ options.js:419Understand this errorAI
options.js:30 Error in delayed refresh: ReferenceError: setupForceRefreshButton is not defined
    at loadAudioList (options.js:432:7)
    at async options.js:26:9
(anonymous) @ options.js:30Understand this errorAI
dbHelper.js:357 Transaction completed successfully

================
File: attached_assets/Pasted-options-js-442-Error-in-loadAudioList-TypeError-Assignment-to-constant-variable-at-loadAudioL-1743831115258.txt
================
options.js:442 Error in loadAudioList: TypeError: Assignment to constant variable.
    at loadAudioList (options.js:204:10)
    at async options.js:155:7
loadAudioList @ options.js:442Understand this errorAI
options.js:160 Page focused, refreshing audio list
options.js:182 loadAudioList called with query: 
dbHelper.js:73 Opening database connection...
dbHelper.js:106 Existing database connection is valid
dbHelper.js:287 Database state: Object
options.js:194 Current database state: Object
options.js:442 Error in loadAudioList: TypeError: Assignment to constant variable.
    at loadAudioList (options.js:204:10)
    at async options.js:161:7
loadAudioList @ options.js:442Understand this errorAI
options.js:160 Page focused, refreshing audio list
options.js:182 loadAudioList called with query: 
dbHelper.js:73 Opening database connection...
dbHelper.js:106 Existing database connection is valid
dbHelper.js:287 Database state: Object
options.js:194 Current database state: Object
options.js:442 Error in loadAudioList: TypeError: Assignment to constant variable.
    at loadAudioList (options.js:204:10)
    at async options.js:161:7
loadAudioList @ options.js:442Understand this errorAI
options.js:154 Refreshing audio list...
options.js:182 loadAudioList called with query: 
dbHelper.js:73 Opening database connection...
dbHelper.js:106 Existing database connection is valid
dbHelper.js:287 Database state: Object
options.js:194 Current database state: Object
options.js:442 Error in loadAudioList: TypeError: Assignment to constant variable.
    at loadAudioList (options.js:204:10)
    at async options.js:155:7
loadAudioList @ options.js:442Understand this errorAI
options.js:469 Failed to refresh audio list: TypeError: Assignment to constant variable.
    at HTMLButtonElement.<anonymous> (options.js:463:16)
(anonymous) @ options.js:469Understand this errorAI
options.js:154 Refreshing audio list...
options.js:182 loadAudioList called with query: 
dbHelper.js:73 Opening database connection...
dbHelper.js:106 Existing database connection is valid
dbHelper.js:287 Database state: {isOpen: true, objectStoreExists: true, recordCount: 0, dbName: 'kokoroTts', dbVersion: 1}
options.js:194 Current database state: {isOpen: true, objectStoreExists: true, recordCount: 0, dbName: 'kokoroTts', dbVersion: 1}
options.js:442 Error in loadAudioList: TypeError: Assignment to constant variable.
    at loadAudioList (options.js:204:10)
    at async options.js:155:7

================
File: attached_assets/Pasted-Received-playAudio-message-action-playAudio-url-https-fal-media-files-tiger-gy-C1T-fTR8s4G-1743337088354.txt
================
Received playAudio message: {action: 'playAudio', url: 'https://fal.media/files/tiger/gy-C1T-fTR8s4Gs2bUAmt_tmpuc3ye14g.wav', text: 'Configure your App Your code was successfully impo…esults of your code will appear here when you run'}
_app-f2ae44c5ffe03ab9.js:30 
            
            
           POST https://logs.browser-intake-us5-datadoghq.com/api/v2/logs?ddsource=browser&ddtags=sdk_version%3A4.46.0%2Capi%3Abeacon%2Cenv%3Aproduction%2Cservice%3Awebsite%2Cversion%3A1a31a381&dd-api-key=pub31a5047a3a4692afb84a423db984dc57&dd-evp-origin-version=4.46.0&dd-evp-origin=browser&dd-request-id=8826f22b-eb95-4ce0-bdf6-23f707e78afa net::ERR_NAME_NOT_RESOLVED
(anonymous) @ _app-f2ae44c5ffe03ab9.js:30
sendOnExit @ _app-f2ae44c5ffe03ab9.js:30
e.flush @ _app-f2ae44c5ffe03ab9.js:15
(anonymous) @ _app-f2ae44c5ffe03ab9.js:15
(anonymous) @ _app-f2ae44c5ffe03ab9.js:15
e.notify @ _app-f2ae44c5ffe03ab9.js:15
f @ _app-f2ae44c5ffe03ab9.js:15
(anonymous) @ _app-f2ae44c5ffe03ab9.js:15
(anonymous) @ _app-f2ae44c5ffe03ab9.js:15
e.notify @ _app-f2ae44c5ffe03ab9.js:15
r.capture @ _app-f2ae44c5ffe03ab9.js:15
d @ _app-f2ae44c5ffe03ab9.js:15
(anonymous) @ _app-f2ae44c5ffe03ab9.js:15Understand this errorAI
dbHelper.js:139 Saving audio with text: Configure your App Your code was successfully imported from GitHub. We've created a .replit file, which configures your App's behavior. Learn more about .replit files.  To get started, verify our recommended platform dependencies and commands. If you're still deciding, try asking AI.  Modules Modules combine support for programming languages, formatters, and packagers. Node.js 20.18.1 Node.js packager (npm, yarn, pnpm, bun) Prettier 3.3.3 TypeScript Language Server 4.3.3 HTML Language Server TypeScript Language Server 4.3.3 CSS Language Server Commands Run command  Add a run command Use either a dev server or start command. Not sure what to use or running multiple apps? Kokoro TTS Reader Chrome Extension 選択したテキストをKokoro TTSを使って音声に変換するChrome拡張機能です。  機能 ウェブページ上の任意のテキストを選択して音声に変換 コンテキストメニュー（右クリックメニュー）から簡単に実行 Kokoro TTSのAI音声を使用した高品質な音声合成 設定画面でAPIキーの管理が可能 インストール方法 このリポジトリをクローンまたはダウンロードします Chrome拡張機能の管理ページ（chrome://extensions/）を開きます 右上の「デベロッパーモード」をオンにします 「パッケージ化されていない拡張機能を読み込む」をクリックし、クローンしたフォルダを選択します 使用方法 fal.aiでアカウントを作成し、APIキーを取得します 拡張機能のアイコンをクリックし、設定画面でAPIキーを入力します ウェブページ上で任意のテキストを選択します 右クリックして「選択テキストをKokoroTTSで読み上げ」を選択します 生成された音声が自動的に再生されます 技術仕様 Chrome Manifest V3を使用 fal.aiのKokoro TTS APIを使用 バックグラウンドワーカーとコンテンツスクリプトの連携による実装 必要な権限 contextMenus: コンテキストメニューの作成に使用 storage: APIキーの保存に使用 activeTab: 現在のタブでのスクリプト実行に使用 scripting: コンテンツスクリプトの動的注入に使用 対応URL すべてのWebサイトで使用可能です（<all_urls>）。  ライセンス MITライセンス  注意事項 この拡張機能を使用するにはfal.aiのAPIキーが必要です APIの利用料金は別途発生する可能性があります（fal.aiの料金プランに従います） Results of your code will appear here when you run
dbHelper.js:36 Opening database: audioStorage
dbHelper.js:53 Database upgrade needed
dbHelper.js:62 Creating object store: audioStore
dbHelper.js:47 Database opened successfully
dbHelper.js:188 Audio saved successfully with ID: 1
contentScript.js:57 Audio saved successfully with ID: 1

================
File: background.js
================
// Function to get API key from storage
async function getFalApiKey() {
  try {
    const result = await chrome.storage.sync.get('falApiKey');
    return result.falApiKey || null;
  } catch (error) {
    console.error('Failed to retrieve API key:', error);
    return null;
  }
}

// Function to show error in the active tab
async function showErrorMessage(message) {
  try {
    const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
    if (tab?.id) {
      await chrome.tabs.sendMessage(tab.id, {
        action: 'showError',
        error: message
      });
    }
  } catch (error) {
    console.error('Failed to show error message:', error);
  }
}

// Function to wait
const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// Function to format URL for logging
function formatUrl(url) {
  try {
    const parsed = new URL(url);
    return `${parsed.protocol}//${parsed.host}${parsed.pathname}`;
  } catch (e) {
    return url;
  }
}

// Function to get result from response URL
async function getResponseResult(responseUrl, apiKey) {
  try {
    const response = await fetch(responseUrl, {
      method: 'GET',
      headers: {
        'Authorization': `Key ${apiKey}`,
        'Accept': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`Failed to get result: ${response.status} - ${await response.text()}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error in getResponseResult:', error);
    throw error;
  }
}

// Function to poll status until completion
async function pollStatus(statusUrl, responseUrl, apiKey, maxAttempts = 30) {
  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    try {
      const response = await fetch(statusUrl, {
        method: 'GET',
        headers: {
          'Authorization': `Key ${apiKey}`,
          'Accept': 'application/json'
        }
      });

      if (!response.ok) {
        throw new Error(`Status check failed: ${response.status} - ${await response.text()}`);
      }

      const status = await response.json();
      if (status.status === 'COMPLETED') {
        return await getResponseResult(responseUrl, apiKey);
      }
    } catch (error) {
      console.error('Error in pollStatus:', error);
      throw error;
    }

    await wait(1000);
  }

  throw new Error('Polling exceeded maximum attempts');
}

// コンテキストメニューの作成
function createContextMenu() {
  chrome.contextMenus.removeAll(() => {
    chrome.contextMenus.create({
      id: "kokoroTTS-read",
      title: "選択テキストをKokoroTTSで読み上げ",
      contexts: ["selection"]
    });
  });
}

// 拡張機能のインストール時とChrome起動時にメニューを作成
chrome.runtime.onInstalled.addListener(createContextMenu);
chrome.runtime.onStartup.addListener(createContextMenu);

// オプションページまたは履歴ページを更新する関数
async function refreshOptionsPage() {
  try {
    const optionsUrl = chrome.runtime.getURL('options.html');
    const historyUrl = chrome.runtime.getURL('history.html');
    
    // options.htmlまたはhistory.htmlを開いているタブを検索
    const tabs = await chrome.tabs.query({ 
      url: [optionsUrl, historyUrl]
    });

    if (tabs.length > 0) {
      console.log('Active pages found, refreshing...');
      
      // すべての該当タブにメッセージを送信
      let successCount = 0;
      for (const tab of tabs) {
        try {
          // タブにメッセージを送信
          await chrome.tabs.sendMessage(tab.id, { 
            action: 'refreshOptionsPage',
            timestamp: Date.now()
          });
          successCount++;
        } catch (tabError) {
          console.warn(`Failed to send message to tab ${tab.id}:`, tabError);
        }
      }
      
      if (successCount > 0) {
        console.log(`Successfully sent refresh messages to ${successCount} tabs`);
        return { success: true, refreshedTabs: successCount };
      }
    }
    
    console.log('No active pages found that can be refreshed');
    return { success: false, error: 'No active pages found' };
  } catch (error) {
    console.error('Failed to refresh pages:', error);
    return { success: false, error: error.message };
  }
}

// メッセージリスナーの追加
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  console.log('Received message in background script:', message, 'from sender:', sender);

  if (message.action === 'refreshOptionsPage') {
    console.log('Processing refresh request, timestamp:', message.timestamp);
    
    // 即座に応答を返す（非同期処理が完了する前に）
    sendResponse({success: true, message: 'Refresh request received'});
    
    // 履歴ページとオプションページを非同期で更新
    setTimeout(async () => {
      try {
        // 少し遅延させて実行（データベース操作完了を待つ）
        await new Promise(resolve => setTimeout(resolve, 500));
        const results = await refreshAllActivePages(message);
        console.log('Page refresh results:', results);
      } catch (err) {
        console.error('Error refreshing pages:', err);
      }
    }, 0);
    
    return true; // 非同期レスポンスのために true を返す
  }
});

// すべてのアクティブなページを更新
async function refreshAllActivePages(message) {
  const optionsUrl = chrome.runtime.getURL('options.html');
  const historyUrl = chrome.runtime.getURL('history.html');
  const results = { options: false, history: false };
  
  try {
    // options.htmlとhistory.htmlを開いているタブを検索
    const tabs = await chrome.tabs.query({ 
      url: [optionsUrl + '*', historyUrl + '*']
    });
    
    console.log('Found active page tabs:', tabs.length);
    
    if (tabs.length === 0) {
      console.log('No active pages found');
      return results;
    }
    
    // すべての該当タブに更新メッセージを送信
    for (const tab of tabs) {
      try {
        console.log('Sending refresh message to tab:', tab.id, tab.url);
        
        const isOptionsPage = tab.url.includes('options.html');
        const action = isOptionsPage ? 'refreshOptionsPage' : 'refreshHistoryPage';
        
        await new Promise((resolve) => {
          chrome.tabs.sendMessage(tab.id, {
            action: action,
            timestamp: message.timestamp || Date.now(),
            force: message.force || false
          }, (response) => {
            const error = chrome.runtime.lastError;
            if (error) {
              console.warn(`Failed to send message to tab ${tab.id}:`, error);
              resolve(false);
            } else {
              console.log(`Successfully sent ${action} to tab ${tab.id}, response:`, response);
              results[isOptionsPage ? 'options' : 'history'] = true;
              resolve(true);
            }
          });
        });
      } catch (tabError) {
        console.warn(`Error processing tab ${tab.id}:`, tabError);
      }
    }
    
    return results;
  } catch (error) {
    console.error('Error in refreshAllActivePages:', error);
    throw error;
  }
}

// コンテキストメニューのクリックイベント処理
chrome.contextMenus.onClicked.addListener(async (info, tab) => {
  if (info.menuItemId === "kokoroTTS-read" && info.selectionText) {
    const apiKey = await getFalApiKey();
    if (!apiKey) {
      await showErrorMessage('APIキーが設定されていません。設定画面で入力してください。');
      chrome.runtime.openOptionsPage();
      return;
    }

    try {
      const apiUrl = 'https://queue.fal.run/fal-ai/kokoro/american-english';
      const requestBody = {
        prompt: info.selectionText,
        voice: "af_heart"
      };

      // APIにリクエストを送信
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Key ${apiKey}`,
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        throw new Error(`API request failed: ${response.status} - ${await response.text()}`);
      }

      const queueResult = await response.json();
      if (!queueResult.status_url || !queueResult.response_url) {
        throw new Error('必要な情報が見つかりません');
      }

      // ステータスをポーリングし、結果を取得
      const result = await pollStatus(queueResult.status_url, queueResult.response_url, apiKey);

      // 音声URLを取得
      let audioUrl = result.audio_url || result.audio?.url || result.output?.url || result.result?.url;
      if (!audioUrl) {
        throw new Error('音声URLが見つかりません');
      }

      // タブの情報を取得
      try {
        const tabInfo = await chrome.tabs.get(tab.id);
        if (!tabInfo?.url?.startsWith('http')) {
          throw new Error('このページでは音声再生を実行できません');
        }
      } catch (error) {
        throw new Error('タブ情報の取得に失敗しました: ' + error.message);
      }

      // コンテンツスクリプトが読み込まれているかチェック
      try {
        await chrome.tabs.sendMessage(tab.id, { type: "PING" });
      } catch {
        await chrome.scripting.executeScript({
          target: { tabId: tab.id },
          files: ['dbHelper.js', 'contentScript.js']
        });
        await wait(500);
      }

      // 音声再生を試行
      await chrome.tabs.sendMessage(tab.id, {
        action: "playAudio",
        url: audioUrl,
        text: info.selectionText
      });

    } catch (error) {
      await showErrorMessage(`エラーが発生しました: ${error.message}`);
    }
  }
});

================
File: code_summary.md
================
# Kokoro TTS Reader Chrome拡張機能 コード解析

## プロジェクト概要
テキスト選択からKokoro TTSを使用して音声合成を行うChrome拡張機能です。音声データの保存と再生管理機能を備えています。

## ファイル構成と役割

### manifest.json
- Chrome拡張機能の設定ファイル
- Manifest V3を採用
- 主な権限：contextMenus, storage, activeTab, scripting
- ホスト権限：すべてのURL、fal.runとfal.mediaドメイン
- セキュリティポリシーとリソースアクセスの設定
- アイコンとオプションページの設定

### background.js
バックグラウンドサービスワーカー
- **主な機能**：
  - APIキーの管理
  - コンテキストメニューの作成と管理
  - Kokoro TTS APIとの通信
  - 音声生成リクエストの処理
- **重要な関数**：
  - `getFalApiKey()`: ストレージからAPIキーを取得
  - `pollStatus()`: 音声生成の状態を監視
  - `showErrorMessage()`: エラーメッセージの表示
  - `getResponseResult()`: API応答の取得

### contentScript.js
Webページに注入されるスクリプト
- **主な機能**：
  - 音声の再生制御
  - 再生用UIの表示
  - データベースとの連携
- **重要な変数**：
  - `playbackState`: 再生状態の管理
  - `currentAudio`: 現在再生中の音声
- **主な関数**：
  - `handleAudioPlayback()`: 音声再生の制御
  - `showPlayButton()`: 再生コントロールUIの表示
  - `refreshOptionsPage()`: オプションページの更新

### dbHelper.js
IndexedDBを使用したデータ管理クラス
- **クラス**: `AudioDatabase`
  - シングルトンパターンを採用
- **データベース構成**：
  - データベース名: 'audioStorage'
  - オブジェクトストア: 'audioStore'
  - インデックス: timestamp, text, fileName, duration
- **主なメソッド**：
  - `saveAudio()`: 音声データの保存
  - `getAudioList()`: 保存済み音声一覧の取得
  - `getAudio()`: 特定の音声データの取得
  - `deleteAudio()`: 音声データの削除

### options.js
設定ページの制御
- **主な機能**：
  - APIキーの設定と保存
  - 保存済み音声の管理と再生
  - 音声検索機能
- **重要な変数**：
  - `audioFiles`: 保存済み音声リスト
  - `currentAudio`: 現在再生中の音声
- **主な関数**：
  - `loadAudioList()`: 音声一覧の読み込みと表示
  - `playAudio()`: 音声の再生
  - `playNextAudio()`, `playPreviousAudio()`: 音声の切り替え

## データ構造

### 音声データ
```javascript
{
  id: number,              // 自動採番ID
  text: string,            // 元のテキスト
  timestamp: string,       // 保存日時
  fileName: string,        // ファイル名
  duration: number,        // 音声の長さ（秒）
  fileSize: number,        // ファイルサイズ（バイト）
  mimeType: string,        // MIMEタイプ
  data: string            // Base64エンコードされた音声データ
}
```

## 外部依存関係
- **fal.ai API**: 音声合成サービス
  - エンドポイント: https://queue.fal.run/fal-ai/kokoro/american-english
  - 認証: APIキーベース

## 処理フロー
1. テキスト選択とコンテキストメニュークリック
2. APIキー確認とKokoro TTS APIリクエスト
3. 音声生成状態の監視（ポーリング）
4. 音声データの取得と再生
5. IndexedDBへの保存（任意）
6. オプションページでの音声管理と再生

================
File: contentScript.js
================
// グローバル変数
let currentAudio = null;
let playbackState = 'idle'; // idle, loading, playing, paused, error
let db = null;
try {
  db = AudioDatabase.getInstance();
  console.log('AudioDatabase instance created successfully');
} catch (error) {
  console.error('Failed to create AudioDatabase instance:', error);
}
let isProcessing = false;

// オプションページや履歴ページを更新する関数
async function refreshOptionsPage() {
  try {
    console.log('Attempting to refresh pages - timestamp:', Date.now());
    
    // バックグラウンドスクリプトに処理を委譲
    const response = await chrome.runtime.sendMessage({ 
      action: 'refreshOptionsPage',
      timestamp: Date.now(),
      force: true
    });
    
    console.log('Refresh message response:', response);
    
    if (response && response.success) {
      console.log('Successfully refreshed pages with response:', response);
      return true;
    }
    
    console.log('No active pages found that can be refreshed, trying to open history...');
    
    // 最後の手段として通知を表示
    showSuccessNotification('音声が保存されました。履歴ページで確認できます。');
    
    // 履歴ページを強制的に開く
    try {
      const historyUrl = chrome.runtime.getURL('history.html');
      await chrome.tabs.create({ url: historyUrl });
      console.log('History page opened successfully');
      return true;
    } catch (tabError) {
      console.error('Failed to open history tab:', tabError);
      return false;
    }
  } catch (error) {
    console.error('Failed to refresh pages:', error);
    showSuccessNotification('音声が保存されました。履歴ページで確認できます。');
    return false;
  }
}

// Listen for messages from background script
chrome.runtime.onMessage.addListener(async (message, sender, sendResponse) => {
  if (message.type === "PING") {
    sendResponse({ status: "ok" });
    return;
  }

  if (message.action === "playAudio") {
    try {
      console.log('Received playAudio message:', message);

      // 音声URL取得
      const audioUrl = message.url;
      if (!audioUrl) {
        throw new Error('Audio URL is missing');
      }

      // 音声データをフェッチ
      const response = await fetch(audioUrl);
      if (!response.ok) {
        throw new Error(`Failed to fetch audio: ${response.status}`);
      }

      // Blobとして取得
      const audioBlob = await response.blob();

      // テキスト情報を取得
      const text = message.text || '音声データ';

      // 音声を再生（先に再生を行う）
      console.log('Preparing audio for playback...');
      let playbackComplete = false;
      
      const playAudioPromise = new Promise((resolve, reject) => {
        try {
          const blobUrl = URL.createObjectURL(audioBlob);
          const audio = new Audio();
          
          // 再生のためのイベントリスナーを設定
          let playbackStarted = false;
          
          // 再生準備完了イベント
          audio.oncanplaythrough = () => {
            console.log('Audio is ready to play');
            // 一度だけ再生を開始
            if (!playbackStarted) {
              playbackStarted = true;
              console.log('Starting audio playback...');
              try {
                audio.play()
                  .catch(error => {
                    console.error('Audio play promise rejected:', error);
                    showError(`音声の再生に失敗しました: ${error.message}`);
                    URL.revokeObjectURL(blobUrl);
                    reject(error);
                  });
              } catch (innerError) {
                console.error('Error starting playback:', innerError);
                showError(`音声の再生開始に失敗しました: ${innerError.message}`);
                URL.revokeObjectURL(blobUrl);
                reject(innerError);
              }
            }
          };

          audio.onended = () => {
            console.log('Audio playback ended');
            playbackComplete = true;
            URL.revokeObjectURL(blobUrl);
            resolve();
          };

          audio.onerror = (error) => {
            console.error('Audio playback error:', error);
            URL.revokeObjectURL(blobUrl);
            showError(`音声の再生中にエラーが発生しました: ${error.message || '不明なエラー'}`);
            reject(error);
          };

          // ソースを設定して読み込み開始
          audio.src = blobUrl;
          audio.load();
          
          // 10秒以上再生が始まらなかった場合のタイムアウト処理
          setTimeout(() => {
            if (!playbackStarted) {
              console.warn('Audio playback timeout');
              showError('音声の読み込みがタイムアウトしました');
              URL.revokeObjectURL(blobUrl);
              reject(new Error('Audio playback timeout'));
            }
          }, 10000);
        } catch (playError) {
          console.error('Caught error during audio playback setup:', playError);
          showError(`音声の再生準備中にエラーが発生しました: ${playError.message}`);
          reject(playError);
        }
      });

      // 通知を表示
      showSuccessNotification('音声の再生を開始しました');
      
      // 音声の再生が完了した後にデータベースへ保存する
      await playAudioPromise;
      
      try {
        console.log('音声再生完了、データベースに保存を開始します');
        
        // データベース接続を確認
        if (!db) {
          console.log('データベースインスタンスの再取得を試みます');
          db = AudioDatabase.getInstance();
          await db.openDB(true);
        }

        // Blobデータの検証
        if (!audioBlob) {
          throw new Error('音声データ（Blob）が見つかりません');
        }
        console.log('音声データのサイズ:', audioBlob.size, 'bytes');

        // データベースの状態を確認
        const dbState = await db.checkDatabaseState();
        console.log('データベースの状態:', dbState);

        if (!dbState.isOpen || !dbState.objectStoreExists) {
          throw new Error('データベースが正しく初期化されていません');
        }

        // データベースに保存するデータの詳細をログ出力
        console.log('データベースに保存するデータ:', {
          textLength: text.length,
          blobSize: audioBlob.size,
          timestamp: new Date().toISOString()
        });

        // データベースに音声を保存
        const audioId = await db.saveAudio(audioBlob, text);
        console.log('音声を保存しました。ID:', audioId);

        if (!audioId) {
          throw new Error('音声の保存に失敗しました（IDが返されませんでした）');
        }

        // 保存確認のためデータを読み込み
        const savedAudio = await db.getAudio(audioId);
        if (!savedAudio || !savedAudio.blob) {
          throw new Error('保存した音声データの確認に失敗しました');
        }

        console.log('保存した音声データを確認しました:', {
          id: savedAudio.id,
          textLength: savedAudio.text.length,
          blobSize: savedAudio.blob.size,
          timestamp: savedAudio.timestamp
        });

        showSuccessNotification('音声データを保存しました');

        // オプションページの更新処理
        try {
          // 開いているオプションページを探してメッセージを送信
          const optionsUrl = chrome.runtime.getURL('options.html');
          console.log('Sending refresh message to options page');
          
          chrome.runtime.sendMessage({ 
            action: 'refreshOptionsPage',
            timestamp: Date.now() // タイムスタンプを追加して毎回異なるメッセージにする
          }, (response) => {
            if (chrome.runtime.lastError) {
              console.log('Refresh message error (expected if options not open):', chrome.runtime.lastError);
              return;
            }
            console.log('Refresh options page response:', response);
          });
        } catch (msgError) {
          console.log('Failed to send refresh message:', msgError);
          // エラーを無視して処理を続行
        }
      } catch (error) {
        console.error('Error in audio save process:', error);
        showError(`音声の保存に失敗しました: ${error.message}`);
        throw error;
      }

    } catch (error) {
      console.error('Error in playAudio:', error);
      showError(`音声の再生に失敗しました: ${error.message}`);
    }
  } else if (message.action === "showError") {
    showError(message.error);
  }
});


// エラーメッセージを表示
function showError(message) {
  // すでに存在する通知を削除
  const existingNotification = document.getElementById('kokoro-tts-notification');
  if (existingNotification) {
    existingNotification.remove();
  }

  const notification = document.createElement('div');
  notification.id = 'kokoro-tts-notification';
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background-color: #ffebee;
    color: #c62828;
    padding: 12px 16px;
    border-radius: 4px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    z-index: 10000;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
    font-size: 14px;
    max-width: 400px;
    word-break: break-word;
  `;

  notification.innerHTML = `
    <div style="display: flex; align-items: center;">
      <span style="margin-right: 8px;">⚠️</span>
      <span>${message}</span>
    </div>
  `;

  document.body.appendChild(notification);

  // 5秒後に通知を消す
  setTimeout(() => {
    if (notification && notification.parentElement) {
      notification.remove();
    }
  }, 5000);
}

// 成功通知を表示
function showSuccessNotification(message) {
  // すでに存在する通知を削除
  const existingNotification = document.getElementById('kokoro-tts-notification');
  if (existingNotification) {
    existingNotification.remove();
  }

  const notification = document.createElement('div');
  notification.id = 'kokoro-tts-notification';
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background-color: #e8f5e9;
    color: #2e7d32;
    padding: 12px 16px;
    border-radius: 4px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    z-index: 10000;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
    font-size: 14px;
    max-width: 400px;
    word-break: break-word;
  `;

  notification.innerHTML = `
    <div style="display: flex; align-items: center;">
      <span style="margin-right: 8px;">✅</span>
      <span>${message}</span>
    </div>
  `;

  document.body.appendChild(notification);

  // 3秒後に通知を消す
  setTimeout(() => {
    if (notification && notification.parentElement) {
      notification.remove();
    }
  }, 3000);
}

================
File: dbHelper.js
================
class AudioDatabase {
  static instance = null;
  static db = null;

  constructor() {
    this.dbName = 'kokoroTts';
    this.dbVersion = 2;
    this.db = null;
    this.isInitialized = false;
    this.connectionPromise = null;
  }

  static getInstance() {
    if (!AudioDatabase.instance) {
      AudioDatabase.instance = new AudioDatabase();
      console.log('Created new AudioDatabase instance');
    }
    return AudioDatabase.instance;
  }

  async getConnection() {
    if (this.connectionPromise) {
      return this.connectionPromise;
    }

    this.connectionPromise = new Promise((resolve, reject) => {
      console.log('Opening new database connection...');
      const request = indexedDB.open(this.dbName, this.dbVersion);

      request.onerror = (event) => {
        console.error('Database error:', event.target.error);
        this.isInitialized = false;
        this.connectionPromise = null;
        reject(event.target.error);
      };

      request.onupgradeneeded = (event) => {
        console.log('Database upgrade needed');
        const db = event.target.result;
        
        if (!db.objectStoreNames.contains('audios')) {
          console.log('Creating audios object store');
          const store = db.createObjectStore('audios', { 
            keyPath: 'id', 
            autoIncrement: true 
          });
          store.createIndex('timestamp', 'timestamp', { unique: false });
          store.createIndex('text', 'text', { unique: false });
        }
      };

      request.onsuccess = (event) => {
        const db = event.target.result;
        this.db = db;
        this.isInitialized = true;
        console.log('Database connection established');

        db.onversionchange = () => {
          if (db) {
            db.close();
            this.isInitialized = false;
            this.connectionPromise = null;
          }
        };

        resolve(db);
      };
    });

    return this.connectionPromise;
  }

  async openDB(forceReopen = false) {
    if (forceReopen) {
      if (this.db) {
        this.db.close();
      }
      this.db = null;
      this.isInitialized = false;
      this.connectionPromise = null;
    }

    return this.getConnection();
  }

  async saveAudio(audioBlob, text) {
    console.log('Starting saveAudio operation...');

    try {
      if (!audioBlob || !(audioBlob instanceof Blob)) {
        throw new Error('無効な音声データです');
      }
      
      if (!text || typeof text !== 'string') {
        throw new Error('無効なテキストデータです');
      }

      const db = await this.getConnection();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(['audios'], 'readwrite');
        const store = transaction.objectStore('audios');

        const record = {
          blob: audioBlob,
          text: text.substring(0, 1000),
          timestamp: new Date(),
          fileSize: audioBlob.size
        };

        const request = store.add(record);

        request.onsuccess = (event) => {
          const id = event.target.result;
          console.log('Audio saved with ID:', id);
          resolve(id);
        };

        transaction.oncomplete = () => {
          console.log('Save transaction completed');
        };

        request.onerror = transaction.onerror = (event) => {
          console.error('Error in save operation:', event.target.error);
          reject(event.target.error);
        };
      });
    } catch (error) {
      console.error('Error in saveAudio:', error);
      throw error;
    }
  }

  async getAudioList() {
    console.log('Getting audio list...');
    
    try {
      const db = await this.getConnection();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(['audios'], 'readonly');
        const store = transaction.objectStore('audios');
        const request = store.getAll();

        request.onsuccess = () => {
          const records = request.result || [];
          console.log(`Retrieved ${records.length} audio records`);
          resolve(records);
        };

        request.onerror = transaction.onerror = (event) => {
          console.error('Error getting audio list:', event.target.error);
          reject(event.target.error);
        };
      });
    } catch (error) {
      console.error('Error in getAudioList:', error);
      return [];
    }
  }

  async getAudio(id) {
    console.log('Getting audio with ID:', id);
    
    try {
      const db = await this.getConnection();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(['audios'], 'readonly');
        const store = transaction.objectStore('audios');
        const request = store.get(id);

        request.onsuccess = () => {
          resolve(request.result);
        };

        request.onerror = (event) => {
          console.error('Error getting audio:', event.target.error);
          reject(event.target.error);
        };
      });
    } catch (error) {
      console.error('Error in getAudio:', error);
      throw error;
    }
  }

  async deleteAudio(id) {
    console.log('Deleting audio with ID:', id);
    
    try {
      const db = await this.getConnection();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(['audios'], 'readwrite');
        const store = transaction.objectStore('audios');
        const request = store.delete(id);

        request.onsuccess = () => {
          console.log('Audio deleted successfully');
          resolve();
        };

        request.onerror = (event) => {
          console.error('Error deleting audio:', event.target.error);
          reject(event.target.error);
        };
      });
    } catch (error) {
      console.error('Error in deleteAudio:', error);
      throw error;
    }
  }

  async checkDatabaseState() {
    try {
      const db = await this.getConnection();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(['audios'], 'readonly');
        const store = transaction.objectStore('audios');
        const countRequest = store.count();

        countRequest.onsuccess = () => {
          resolve({
            isOpen: true,
            objectStoreExists: true,
            recordCount: countRequest.result,
            dbName: this.dbName,
            dbVersion: this.dbVersion,
            storeNames: Array.from(db.objectStoreNames),
            indexes: Array.from(store.indexNames)
          });
        };

        countRequest.onerror = (event) => {
          reject(event.target.error);
        };
      });
    } catch (error) {
      console.error('Error checking database state:', error);
      return {
        isOpen: false,
        objectStoreExists: false,
        recordCount: 0,
        dbName: this.dbName,
        dbVersion: this.dbVersion,
        error: error.message
      };
    }
  }
}

================
File: dependencies.md
================
# モジュール依存関係図

```mermaid
graph TD
    subgraph Chrome拡張機能
        manifest[manifest.json]
        background[background.js]
        content[contentScript.js]
        db[dbHelper.js]
        options[options.js]
        optionsHTML[options.html]
        styles[styles.css]
    end

    subgraph 外部サービス
        falai[fal.ai API]
    end

    %% マニフェストの依存関係
    manifest -->|定義| background
    manifest -->|定義| content
    manifest -->|定義| optionsHTML

    %% バックグラウンドスクリプトの依存関係
    background -->|API通信| falai
    background -->|メッセージ| content
    background -->|ストレージ| chrome-storage[Chrome Storage API]

    %% コンテンツスクリプトの依存関係
    content -->|データ保存| db
    content -->|メッセージ| background
    content -->|UI表示| styles

    %% オプションページの依存関係
    optionsHTML -->|スタイル| styles
    optionsHTML -->|ロード| options
    optionsHTML -->|ロード| db
    options -->|データ操作| db
    options -->|ストレージ| chrome-storage

    %% データベースの依存関係
    db -->|保存| indexedDB[IndexedDB]

    %% スタイルの適用
    styles -.->|スタイル適用| optionsHTML

    %% Chrome APIの利用
    chrome-apis[Chrome APIs] --> background
    chrome-apis --> content
    chrome-apis --> options

    classDef external fill:#f9f,stroke:#333,stroke-width:2px
    classDef chrome fill:#bbf,stroke:#333,stroke-width:2px
    class falai,indexedDB external
    class chrome-apis,chrome-storage chrome
```

## 依存関係の説明

### コアモジュール間の依存関係
- `manifest.json` はすべてのコンポーネントの設定と権限を定義
- `background.js` は拡張機能のバックグラウンドプロセスとしてfal.ai APIとの通信を管理
- `contentScript.js` はWebページ上でのUI表示と音声再生を担当
- `dbHelper.js` はIndexedDBを使用したデータ永続化を提供
- `options.js` は設定と保存済み音声の管理インターフェースを提供

### 外部依存関係
1. Chrome APIs
   - Storage API: 設定の保存
   - Tabs API: タブ管理
   - Runtime API: メッセージング
   - ContextMenus API: 右クリックメニュー

2. 外部サービス
   - fal.ai API: 音声合成サービス

3. ブラウザAPI
   - IndexedDB: 音声データの永続化
   - Audio API: 音声再生

### データフロー
1. ユーザー操作 → `contentScript.js`
2. `contentScript.js` → `background.js` → fal.ai API
3. 音声データ → `dbHelper.js` → IndexedDB
4. 設定データ → Chrome Storage API

================
File: history.html
================
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>音声再生履歴</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
      color: #333;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background-color: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    
    h1 {
      display: flex;
      align-items: center;
      font-size: 24px;
      margin-bottom: 20px;
      color: #333;
    }
    
    h1 i {
      margin-right: 10px;
      color: #2196F3;
    }
    
    .header-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    #status {
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 15px;
      font-weight: 500;
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>
      <i class="material-icons">history</i>
      音声再生履歴
    </h1>
    
    <div class="header-actions">
      <div class="search-bar">
        <i class="material-icons">search</i>
        <input type="text" id="searchInput" placeholder="テキストを検索...">
      </div>
      <button id="refreshButton" class="refresh-button">
        <i class="material-icons">refresh</i>
        更新
      </button>
    </div>
    
    <div id="status"></div>
    
    <div id="audioList" class="audio-list"></div>
    
    <div class="loading">
      <i class="material-icons rotating">refresh</i>
      <p>読み込み中...</p>
    </div>
  </div>

  <script src="dbHelper.js"></script>
  <script src="history.js"></script>
</body>
</html>

================
File: history.js
================
// AudioDatabaseのインスタンスを取得
const db = AudioDatabase.getInstance();
let currentAudio = null;
let currentAudioId = null;
let audioFiles = [];
let lastRefreshTime = 0;
const REFRESH_INTERVAL = 3000; // 3秒ごとに更新

document.addEventListener('DOMContentLoaded', async () => {
  console.log('History page loaded - Initializing...');

  try {
    // データベースの状態を詳細に確認
    const dbState = await db.checkDatabaseState();
    console.log('Database state:', dbState);

    // データベースの初期化を確認
    await db.openDB();
    console.log('Database connection established');

    // 検索機能の実装
    const searchInput = document.getElementById('searchInput');
    let searchTimeout;
    searchInput.addEventListener('input', () => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        loadAudioList(searchInput.value);
      }, 300);
    });

    // 更新ボタンの実装
    const refreshButton = document.getElementById('refreshButton');
    refreshButton.addEventListener('click', async () => {
      try {
        refreshButton.disabled = true;
        refreshButton.innerHTML = '<i class="material-icons">refresh</i>更新中...';
        console.log('Manual refresh requested');

        // データベース接続を確認・リフレッシュ
        await db.openDB();
        await loadAudioList();

        showStatus('音声一覧を更新しました', 'success');
      } catch (error) {
        console.error('Failed to refresh audio list:', error);
        showStatus('更新に失敗しました: ' + error.message, 'error');
      } finally {
        refreshButton.disabled = false;
        refreshButton.innerHTML = '<i class="material-icons">refresh</i>更新';
      }
    });

    // メッセージリスナーを登録 (バックグラウンドスクリプトからの更新メッセージを受け取る)
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      console.log('Received message in history page:', message, 'from sender:', sender);

      if (message.action === 'refreshOptionsPage' || message.action === 'refreshHistoryPage') {
        console.log('Refresh message received:', message.timestamp);

        // 即座に応答を返す
        sendResponse({ success: true, page: 'history', timestamp: Date.now() });

        // データベース接続を更新して、音声リストを再読み込み
        (async () => {
          try {
            console.log('Starting database refresh...');
            
            // 一度データベースの状態を確認
            const dbState = await db.checkDatabaseState();
            console.log('Current database state before refresh:', dbState);
            
            // データベース接続を強制的に再確認・更新
            await db.openDB(true);

            // 強制更新の場合は少し待機
            if (message.force) {
              console.log('Forced refresh - waiting for DB operations to complete');
              await new Promise(resolve => setTimeout(resolve, 1500)); // 1.5秒に延長
            }

            // データを複数回試行して読み込む
            let retryCount = 0;
            const maxRetries = 3;
            let success = false;
            
            while (retryCount < maxRetries && !success) {
              try {
                console.log(`Loading audio list (attempt ${retryCount + 1}/${maxRetries})...`);
                await loadAudioList();
                console.log(`History page refreshed successfully (attempt ${retryCount + 1})`);
                showStatus('データを更新しました', 'success');
                success = true;
              } catch (loadError) {
                console.error(`Error loading audio list (attempt ${retryCount + 1}):`, loadError);
                retryCount++;
                
                if (retryCount < maxRetries) {
                  console.log('Waiting before next attempt...');
                  await new Promise(resolve => setTimeout(resolve, 800)); // 800ms待機
                } else {
                  showStatus('更新中にエラーが発生しました: ' + loadError.message, 'error');
                }
              }
            }
          } catch (err) {
            console.error('Error refreshing history page:', err);
            showStatus('更新中にエラーが発生しました: ' + err.message, 'error');
          }
        })();

        return true; // 非同期レスポンスのためにtrueを返す
      }
    });

    // 初期データ読み込み
    console.log('Starting initial audio list load');
    await loadAudioList();
    console.log('Initial audio list load completed');

    // 定期的な更新
    setInterval(async () => {
      const now = Date.now();
      if (now - lastRefreshTime > REFRESH_INTERVAL) {
        console.log('Auto-refreshing audio list');
        await loadAudioList();
        lastRefreshTime = now;
      }
    }, REFRESH_INTERVAL);

  } catch (error) {
    console.error('Error during initialization:', error);
    showStatus('初期化中にエラーが発生しました: ' + error.message, 'error');
  }
});

// ステータスメッセージを表示
function showStatus(message, type) {
  const status = document.getElementById('status');
  if (!status) return;

  status.textContent = message;
  status.className = type;
  setTimeout(() => {
    status.textContent = '';
    status.className = '';
  }, 3000);
}

// 音声一覧を読み込んで表示
async function loadAudioList(searchQuery = '') {
  console.log('loadAudioList called with query:', searchQuery);
  const audioList = document.getElementById('audioList');
  const loading = document.querySelector('.loading');

  if (!audioList) {
    console.error('audioList element not found');
    return;
  }

  try {
    loading.classList.add('active');
    audioList.innerHTML = '';

    // データベース接続を完全に更新 (強制的に再作成)
    db = AudioDatabase.getInstance();
    await db.openDB(true); // 強制的に再オープン
    console.log('Fetching audio list from database...');

    // 複数回試行するための準備
    let retryCount = 0;
    const maxRetries = 3;

    while (retryCount < maxRetries && (!audioFiles || audioFiles.length === 0)) {
      console.log(`Getting audio list (attempt ${retryCount + 1}/${maxRetries})...`);
      audioFiles = await db.getAudioList();
      console.log(`Attempt ${retryCount + 1}: Retrieved audio files:`, audioFiles.length, 'items');

      if (audioFiles.length > 0) {
        break; // データが見つかったらループを抜ける
      }

      retryCount++;
      if (retryCount < maxRetries) {
        console.log(`No audio files found, waiting before next attempt...`);
        await new Promise(resolve => setTimeout(resolve, 500)); // 次の試行前に少し待機
      }
    }


    const filteredFiles = searchQuery
      ? audioFiles.filter(audio =>
          audio.text.toLowerCase().includes(searchQuery.toLowerCase()))
      : audioFiles;

    console.log('Filtered audio files:', filteredFiles.length, 'items');

    if (filteredFiles.length === 0) {
      console.log('No audio files found after filtering');
      audioList.innerHTML = `
        <div class="empty-state">
          <i class="material-icons">music_off</i>
          <p>${searchQuery ? '検索結果が見つかりません' : '保存された音声はありません'}</p>
          <button id="forceRefreshButton" class="refresh-button" style="margin-top: 15px;">
            <i class="material-icons">refresh</i>強制更新
          </button>
        </div>
      `;

      // 強制更新ボタンのイベントリスナーを追加
      const forceRefreshButton = document.getElementById('forceRefreshButton');
      if (forceRefreshButton) {
        forceRefreshButton.addEventListener('click', async () => {
          try {
            forceRefreshButton.disabled = true;
            forceRefreshButton.innerHTML = '<i class="material-icons">refresh</i>更新中...';

            // データベース接続を完全に更新
            db = AudioDatabase.getInstance();
            await db.openDB();
            await loadAudioList();

            showStatus('音声一覧を強制更新しました', 'success');
          } catch (error) {
            console.error('Failed to refresh audio list:', error);
            showStatus('更新に失敗しました: ' + error.message, 'error');
          } finally {
            if (forceRefreshButton) {
              forceRefreshButton.disabled = false;
              forceRefreshButton.innerHTML = '<i class="material-icons">refresh</i>強制更新';
            }
          }
        });
      }

      return;
    }

    // 日付でソート（新しい順）
    filteredFiles.sort((a, b) =>
      new Date(b.timestamp) - new Date(a.timestamp)
    );

    console.log('Rendering audio items...');
    for (const audio of filteredFiles) {
      const item = document.createElement('div');
      item.className = 'audio-item';
      item.dataset.audioId = audio.id;

      const text = document.createElement('div');
      text.className = 'audio-text';
      text.textContent = audio.text;

      const metadata = document.createElement('div');
      metadata.className = 'audio-metadata';

      // メタデータの表示を改善
      const duration = audio.duration ? `${Math.round(audio.duration)}秒` : '不明';
      const fileSize = audio.fileSize ? `${(audio.fileSize / 1024).toFixed(1)}KB` : '不明';

      metadata.innerHTML = `
        <div class="metadata-row">
          <i class="material-icons">schedule</i>
          ${new Date(audio.timestamp).toLocaleString()}
        </div>
        <div class="metadata-row">
          <i class="material-icons">timer</i>
          ${duration}
          <i class="material-icons" style="margin-left: 10px;">save</i>
          ${fileSize}
        </div>
      `;

      const controls = document.createElement('div');
      controls.className = 'audio-controls';

      // 前の音声ボタン
      const prevButton = document.createElement('button');
      prevButton.className = 'nav-button prev-button';
      prevButton.innerHTML = '<i class="material-icons">skip_previous</i>';
      prevButton.onclick = () => playPreviousAudio(audio.id);
      prevButton.title = '前の音声';

      // 再生ボタン
      const playButton = document.createElement('button');
      playButton.className = 'play-button';
      playButton.innerHTML = '<i class="material-icons">play_arrow</i>再生';
      playButton.onclick = async () => {
        try {
          playButton.disabled = true;
          currentAudioId = audio.id;

          // データベースから音声データを取得
          console.log('Fetching audio data for ID:', audio.id);
          const audioData = await db.getAudio(audio.id);

          if (!audioData) {
            throw new Error('音声データが見つかりません (データなし)');
          }

          if (!audioData.blob) {
            throw new Error('音声データが見つかりません (Blobなし)');
          }

          // 音声を再生
          const success = await playAudio(audioData.blob);

          if (success) {
            playButton.innerHTML = '<i class="material-icons">pause</i>一時停止';
          }
        } catch (error) {
          console.error('Failed to play audio:', error);
          showStatus('音声の再生に失敗しました: ' + error.message, 'error');
        } finally {
          playButton.disabled = false;
        }
      };

      // 次の音声ボタン
      const nextButton = document.createElement('button');
      nextButton.className = 'nav-button next-button';
      nextButton.innerHTML = '<i class="material-icons">skip_next</i>';
      nextButton.onclick = () => playNextAudio(audio.id);
      nextButton.title = '次の音声';

      const deleteButton = document.createElement('button');
      deleteButton.className = 'delete-button';
      deleteButton.innerHTML = '<i class="material-icons">delete</i>削除';
      deleteButton.onclick = async () => {
        if (confirm('この音声を削除してもよろしいですか？')) {
          try {
            await db.deleteAudio(audio.id);
            await loadAudioList(searchQuery);
            showStatus('音声を削除しました', 'success');
          } catch (error) {
            console.error('Failed to delete audio:', error);
            showStatus('音声の削除に失敗しました', 'error');
          }
        }
      };

      controls.appendChild(prevButton);
      controls.appendChild(playButton);
      controls.appendChild(nextButton);
      controls.appendChild(deleteButton);

      item.appendChild(text);
      item.appendChild(metadata);
      item.appendChild(controls);
      audioList.appendChild(item);
    }

    // 更新時間を記録
    lastRefreshTime = Date.now();
    showStatus(`${filteredFiles.length}件の音声データを読み込みました`, 'success');
  } catch (error) {
    console.error('Error in loadAudioList:', error);
    audioList.innerHTML = `
      <div class="empty-state">
        <i class="material-icons">error</i>
        <p>音声の読み込みに失敗しました: ${error.message}</p>
        <button id="forceRefreshButton" class="refresh-button" style="margin-top: 15px;">
          <i class="material-icons">refresh</i>強制更新
        </button>
      </div>
    `;

    // 強制更新ボタンのイベントリスナーを追加
    const forceRefreshButton = document.getElementById('forceRefreshButton');
    if (forceRefreshButton) {
      forceRefreshButton.addEventListener('click', async () => {
        try {
          forceRefreshButton.disabled = true;
          forceRefreshButton.innerHTML = '<i class="material-icons">refresh</i>更新中...';

          // データベース接続を完全に更新
          db = AudioDatabase.getInstance();
          await db.openDB();
          await loadAudioList();

          showStatus('音声一覧を強制更新しました', 'success');
        } catch (error) {
          console.error('Failed to refresh audio list:', error);
          showStatus('更新に失敗しました: ' + error.message, 'error');
        } finally {
          if (forceRefreshButton) {
            forceRefreshButton.disabled = false;
            forceRefreshButton.innerHTML = '<i class="material-icons">refresh</i>強制更新';
          }
        }
      });
    }
  } finally {
    loading.classList.remove('active');
  }
}

// 音声を再生
async function playAudio(blob) {
  if (currentAudio) {
    currentAudio.pause();
    URL.revokeObjectURL(currentAudio.src);
    currentAudio = null;
  }

  try {
    if (!blob) {
      throw new Error('Blob data is missing');
    }

    const blobUrl = URL.createObjectURL(blob);
    const audio = new Audio(blobUrl);
    currentAudio = audio;

    audio.onended = () => {
      URL.revokeObjectURL(blobUrl);
      currentAudio = null;
      // 再生終了時に自動で次の音声を再生
      if (currentAudioId) {
        playNextAudio(currentAudioId);
      }
    };

    audio.onerror = (error) => {
      URL.revokeObjectURL(blobUrl);
      currentAudio = null;
      console.error('Audio playback error:', error);
      throw new Error('音声の再生中にエラーが発生しました');
    };

    // 現在再生中の項目をハイライト
    document.querySelectorAll('.audio-item').forEach(item => {
      item.classList.remove('playing');
    });
    const currentItem = document.querySelector(`.audio-item[data-audio-id="${currentAudioId}"]`);
    if (currentItem) {
      currentItem.classList.add('playing');
    }

    await audio.play();
    return true;
  } catch (error) {
    console.error('Failed to play audio:', error);
    showStatus('音声の再生に失敗しました: ' + error.message, 'error');
    return false;
  }
}

// 前の音声を再生
async function playPreviousAudio(currentId) {
  const sortedFiles = [...audioFiles].sort((a, b) =>
    new Date(b.timestamp) - new Date(a.timestamp)
  );
  const currentIndex = sortedFiles.findIndex(audio => audio.id === currentId);
  if (currentIndex > 0) {
    const previousAudio = sortedFiles[currentIndex - 1];
    currentAudioId = previousAudio.id;

    try {
      const audioData = await db.getAudio(previousAudio.id);
      if (audioData && audioData.blob) {
        playAudio(audioData.blob);
      }
    } catch (error) {
      console.error('Failed to play previous audio:', error);
      showStatus('前の音声の再生に失敗しました', 'error');
    }
  }
}

// 次の音声を再生
async function playNextAudio(currentId) {
  const sortedFiles = [...audioFiles].sort((a, b) =>
    new Date(b.timestamp) - new Date(a.timestamp)
  );
  const currentIndex = sortedFiles.findIndex(audio => audio.id === currentId);
  if (currentIndex >= 0 && currentIndex < sortedFiles.length - 1) {
    const nextAudio = sortedFiles[currentIndex + 1];
    currentAudioId = nextAudio.id;

    try {
      const audioData = await db.getAudio(nextAudio.id);
      if (audioData && audioData.blob) {
        playAudio(audioData.blob);
      }
    } catch (error) {
      console.error('Failed to play next audio:', error);
      showStatus('次の音声の再生に失敗しました', 'error');
    }
  }
}

================
File: LICENSE
================
MIT License

Copyright (c) 2024 ganpare

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: manifest.json
================
{
  "manifest_version": 3,
  "name": "Kokoro TTS Reader",
  "version": "1.0.0",
  "permissions": [
    "contextMenus",
    "storage",
    "activeTab",
    "scripting",
    "unlimitedStorage",
    "tabs"
  ],
  "host_permissions": [
    "<all_urls>",
    "https://queue.fal.run/*",
    "https://fal.media/*"
  ],
  "content_security_policy": {
    "extension_pages": "script-src 'self'; object-src 'self'; media-src 'self' blob: https://fal.media/* data:;",
    "sandbox": "sandbox allow-scripts allow-forms allow-popups allow-modals; script-src 'self'; media-src 'self' blob: https://fal.media/* data:;",
    "content_scripts": "script-src 'self'; media-src * blob: https://fal.media/* data:;"
  },
  "web_accessible_resources": [{
    "resources": ["*.wav", "*.mp3"],
    "matches": ["<all_urls>"]
  }],
  "background": {
    "service_worker": "background.js"
  },
  "content_scripts": [{
    "matches": ["<all_urls>"],
    "js": ["dbHelper.js", "contentScript.js"],
    "run_at": "document_start"
  }],
  "options_ui": {
    "page": "options.html",
    "open_in_tab": true
  },
  "web_accessible_resources": [
    {
      "resources": ["history.html"],
      "matches": ["<all_urls>"]
    }
  ],
  "icons": {
    "16": "icons/icon16.png",
    "32": "icons/icon32.png",
    "48": "icons/icon48.png",
    "128": "icons/icon128.png"
  }
}

================
File: options.html
================
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Kokoro TTS Settings</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link href="styles.css" rel="stylesheet">
</head>
<body>
  <div class="container">
    <div class="header">
      <img src="icons/icon48.png" alt="Kokoro TTS">
      <h1>Kokoro TTS 設定</h1>
    </div>

    <div class="section">
      <h2 class="section-title">
        <i class="material-icons">vpn_key</i>
        API設定
      </h2>
      <div class="api-input-container">
        <div class="form-group">
          <label for="apiKey">fal.ai API Key:</label>
          <input type="text" id="apiKey" placeholder="APIキーを入力してください">
        </div>
        <button id="save" class="primary-button">
          <i class="material-icons">save</i>
          保存
        </button>
      </div>
      <div id="status"></div>
    </div>

    <div class="section">
      <h2 class="section-title">
        <i class="material-icons">library_music</i>
        保存済み音声一覧
      </h2>
      <div class="audio-list-actions">
        <div class="search-bar">
          <i class="material-icons">search</i>
          <input type="text" id="searchInput" placeholder="テキストを検索...">
        </div>
        <button id="refreshButton" class="refresh-button">
          <i class="material-icons">refresh</i>
          更新
        </button>
      </div>
      <div id="audioList" class="audio-list"></div>
      <div class="loading">
        <div class="spinner"></div>
        <p>読み込み中...</p>
      </div>
    </div>
  </div>

  <script src="dbHelper.js"></script>
  <script src="options.js"></script>
</body>
</html>

================
File: options.js
================
let db = AudioDatabase.getInstance();
let currentAudio = null;
let currentAudioId = null;
let audioFiles = [];

// 共通ユーティリティ関数
// データベース接続を更新する共通関数
async function refreshDatabaseConnection(force = false) {
  console.log(`Refreshing database connection${force ? ' (forced)' : ''}`);
  db = AudioDatabase.getInstance();
  await db.openDB(force);
  return db;
}

// ボタンの状態を更新する共通関数
function updateButtonState(button, isLoading, defaultText, loadingText, icon = 'refresh') {
  if (!button) return;
  
  button.disabled = isLoading;
  button.innerHTML = `<i class="material-icons">${icon}</i>${isLoading ? loadingText : defaultText}`;
}

// エラーハンドリングの共通関数
function handleError(error, errorMessage) {
  console.error(errorMessage, error);
  showStatus(`${errorMessage}: ${error.message}`, 'error');
}

// 音声リストを更新する共通関数
async function refreshAudioList(query = '') {
  try {
    await refreshDatabaseConnection(true);
    await loadAudioList(query);
    showStatus('音声一覧を更新しました', 'success');
    return true;
  } catch (error) {
    handleError(error, '更新に失敗しました');
    return false;
  }
}

// UIコンポーネント作成関数
function createButton(className, icon, text, onClick, title = '') {
  const button = document.createElement('button');
  button.className = className;
  button.innerHTML = `<i class="material-icons">${icon}</i>${text}`;
  button.onclick = onClick;
  if (title) button.title = title;
  return button;
}

// 音声アイテムの作成
function createAudioItem(audio, query) {
  const item = document.createElement('div');
  item.className = 'audio-item';
  item.dataset.audioId = audio.id;

  // テキスト部分
  const text = document.createElement('div');
  text.className = 'audio-text';
  text.textContent = audio.text || 'テキストなし';

  // メタデータ部分
  const metadata = document.createElement('div');
  metadata.className = 'audio-metadata';
  const duration = audio.duration ? `${Math.round(audio.duration)}秒` : '不明';
  const fileSize = audio.fileSize ? `${(audio.fileSize / 1024).toFixed(1)}KB` : '不明';
  metadata.innerHTML = `
    <div class="metadata-row">
      <i class="material-icons">schedule</i>
      ${new Date(audio.timestamp).toLocaleString()}
    </div>
    <div class="metadata-row">
      <i class="material-icons">timer</i>
      ${duration}
      <i class="material-icons" style="margin-left: 10px;">save</i>
      ${fileSize}
    </div>
  `;

  // コントロール部分
  const controls = document.createElement('div');
  controls.className = 'audio-controls';

  // 前の音声ボタン
  const prevButton = createButton('nav-button prev-button', 'skip_previous', '', () => playPreviousAudio(audio.id), '前の音声');

  // 再生ボタン
  const playButton = createButton('play-button', 'play_arrow', '再生', async () => {
    try {
      playButton.disabled = true;
      currentAudioId = audio.id;

      // まずリストから取得したblobを使用
      if (audio.blob) {
        console.log('Using blob data from list for ID:', audio.id);
        const success = await playAudio(audio.blob);
        if (success) {
          playButton.innerHTML = '<i class="material-icons">pause</i>一時停止';
        }
      } else {
        // リストにない場合は個別に取得
        console.log('Blob not in list, fetching audio data for ID:', audio.id);
        const audioData = await db.getAudio(audio.id);

        if (!audioData || !audioData.blob) {
          throw new Error('音声データが見つかりません');
        }

        const success = await playAudio(audioData.blob);
        if (success) {
          playButton.innerHTML = '<i class="material-icons">pause</i>一時停止';
        }
      }
    } catch (error) {
      handleError(error, '音声の再生に失敗しました');
    } finally {
      playButton.disabled = false;
    }
  });

  // 次の音声ボタン
  const nextButton = createButton('nav-button next-button', 'skip_next', '', () => playNextAudio(audio.id), '次の音声');

  // 削除ボタン
  const deleteButton = createButton('delete-button', 'delete', '削除', async () => {
    if (confirm('この音声を削除してもよろしいですか？')) {
      try {
        await db.deleteAudio(audio.id);
        await loadAudioList(query);
        showStatus('音声を削除しました', 'success');
      } catch (error) {
        handleError(error, '音声の削除に失敗しました');
      }
    }
  });

  controls.appendChild(prevButton);
  controls.appendChild(playButton);
  controls.appendChild(nextButton);
  controls.appendChild(deleteButton);

  item.appendChild(text);
  item.appendChild(metadata);
  item.appendChild(controls);
  return item;
}

// 空の状態表示の作成
function createEmptyState(query, error = null) {
  return `
    <div class="empty-state">
      <i class="material-icons">${error ? 'error' : 'music_off'}</i>
      <p>${error ? `音声の読み込みに失敗しました: ${error.message}` : (query ? '検索結果が見つかりません' : '保存された音声はありません')}</p>
    </div>
  `;
}

// メッセージリスナーを設定
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  console.log('Received message in options page:', message);

  if (message.action === 'refreshOptionsPage') {
    console.log('Refreshing options page from message with timestamp:', message.timestamp);
    sendResponse({ success: true });

    setTimeout(async () => {
      try {
        console.log('Delayed refresh starting now');
        await refreshDatabaseConnection(true);
        const dbState = await db.checkDatabaseState();
        console.log('Database state before refresh:', dbState);
        await loadAudioList();
        console.log('Delayed refresh completed successfully');
        showStatus('最新の音声データを読み込みました', 'success');
      } catch (error) {
        handleError(error, '更新中にエラーが発生しました');
        if (message.force) {
          console.log('Force refreshing page due to error...');
          location.reload();
        }
      }
    }, 1500);

    return true;
  }
});

// イベントリスナーの設定
function setupEventListeners() {
  // APIキーの保存
  document.getElementById('save').addEventListener('click', async () => {
    const apiKey = document.getElementById('apiKey').value.trim();
    if (!apiKey) {
      showStatus('APIキーを入力してください', 'error');
      return;
    }

    try {
      await chrome.storage.sync.set({ falApiKey: apiKey });
      showStatus('設定を保存しました', 'success');
    } catch (error) {
      handleError(error, '設定の保存に失敗しました');
    }
  });

  // 検索機能
  const searchInput = document.getElementById('searchInput');
  let searchTimeout;
  searchInput.addEventListener('input', () => {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => loadAudioList(searchInput.value), 300);
  });

  // 更新ボタン
  const refreshButton = document.getElementById('refreshButton');
  refreshButton.addEventListener('click', async () => {
    try {
      updateButtonState(refreshButton, true, '更新', '更新中...');
      await refreshAudioList(searchInput.value);
    } finally {
      updateButtonState(refreshButton, false, '更新', '更新中...');
    }
  });

  // ページがフォーカスされたときに更新
  window.addEventListener('focus', async () => {
    console.log('Page focused, refreshing audio list');
    await loadAudioList();
  });
}

// 初期化処理
document.addEventListener('DOMContentLoaded', async () => {
  console.log('DOM Content Loaded - Initializing options page');

  try {
    const dbState = await db.checkDatabaseState();
    console.log('Database state:', JSON.stringify(dbState, null, 2));
    await refreshDatabaseConnection();
    console.log('Database initialized successfully');

    audioFiles = await db.getAudioList();
    console.log('Number of audio files in database:', audioFiles.length);
    console.log('Audio files:', JSON.stringify(audioFiles, null, 2));

    // 保存されているAPIキーを読み込み
    const result = await chrome.storage.sync.get('falApiKey');
    if (result.falApiKey) {
      document.getElementById('apiKey').value = result.falApiKey;
    }

    // イベントリスナーの設定
    setupEventListeners();

    // 初期データ読み込み
    console.log('Starting initial audio list load');
    await loadAudioList();
    console.log('Initial audio list load completed');
  } catch (error) {
    handleError(error, '初期化中にエラーが発生しました');
  }
});

// ステータスメッセージを表示
function showStatus(message, type) {
  const status = document.getElementById('status');
  status.textContent = message;
  status.className = type;
  setTimeout(() => {
    status.textContent = '';
    status.className = '';
  }, 3000);
}

// 音声一覧を読み込んで表示
async function loadAudioList(query = '') {
  console.log('loadAudioList called with query:', query);
  const audioList = document.getElementById('audioList');
  const loading = document.querySelector('.loading');

  if (!audioList) {
    console.error('audioList element not found');
    return;
  }

  try {
    loading.classList.add('active');
    audioList.innerHTML = '';

    await refreshDatabaseConnection(true);
    console.log('Fetching audio list from database...');

    // 複数回試行するための準備
    let retryCount = 0;
    const maxRetries = 3;

    while (retryCount < maxRetries && (!audioFiles || audioFiles.length === 0)) {
      console.log(`Getting audio list (attempt ${retryCount + 1}/${maxRetries})...`);
      audioFiles = await db.getAudioList();
      console.log(`Attempt ${retryCount + 1}: Retrieved audio files:`, audioFiles.length, 'items');

      if (audioFiles.length > 0) break;
      retryCount++;
      if (retryCount < maxRetries) {
        console.log(`No audio files found, waiting before next attempt...`);
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }

    // Blobデータの確認と取得
    if (audioFiles.length > 0) {
      const itemsWithBlob = audioFiles.filter(item => !!item.blob).length;
      console.log(`Items with blob data: ${itemsWithBlob}/${audioFiles.length}`);

      if (itemsWithBlob < audioFiles.length) {
        console.log('Some items missing blob data, attempting to retrieve them');
        for (let i = 0; i < audioFiles.length; i++) {
          if (!audioFiles[i].blob) {
            try {
              const fullData = await db.getAudio(audioFiles[i].id);
              if (fullData && fullData.blob) {
                audioFiles[i].blob = fullData.blob;
                console.log(`Retrieved missing blob for item ID ${audioFiles[i].id}`);
              }
            } catch (e) {
              console.warn(`Failed to retrieve blob for item ID ${audioFiles[i].id}:`, e);
            }
          }
        }
      }
    }

    const filteredFiles = query
      ? audioFiles.filter(audio => audio.text && audio.text.toLowerCase().includes(query.toLowerCase()))
      : audioFiles;

    console.log('Filtered audio files:', filteredFiles.length, 'items');

    if (filteredFiles.length === 0) {
      console.log('No audio files found after filtering');
      audioList.innerHTML = createEmptyState(query);
      return;
    }

    // 日付でソート（新しい順）
    filteredFiles.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

    console.log('Rendering audio items...');
    for (const audio of filteredFiles) {
      console.log('Creating element for audio ID:', audio.id);
      audioList.appendChild(createAudioItem(audio, query));
    }

    showStatus(`${filteredFiles.length}件の音声データを読み込みました`, 'success');
  } catch (error) {
    handleError(error, '音声の読み込みに失敗しました');
    audioList.innerHTML = createEmptyState(query, error);
  } finally {
    loading.classList.remove('active');
  }
}

// 音声再生関連の関数
async function playAudio(blob) {
  if (currentAudio) {
    currentAudio.pause();
    URL.revokeObjectURL(currentAudio.src);
    currentAudio = null;
  }

  try {
    if (!blob) throw new Error('Blob data is missing');

    const blobUrl = URL.createObjectURL(blob);
    const audio = new Audio(blobUrl);
    currentAudio = audio;

    audio.onended = () => {
      URL.revokeObjectURL(blobUrl);
      currentAudio = null;
      if (currentAudioId) playNextAudio(currentAudioId);
    };

    audio.onerror = (error) => {
      URL.revokeObjectURL(blobUrl);
      currentAudio = null;
      console.error('Audio playback error:', error);
      throw new Error('音声の再生中にエラーが発生しました');
    };

    // 現在再生中の項目をハイライト
    document.querySelectorAll('.audio-item').forEach(item => item.classList.remove('playing'));
    const currentItem = document.querySelector(`.audio-item[data-audio-id="${currentAudioId}"]`);
    if (currentItem) currentItem.classList.add('playing');

    await audio.play();
    return true;
  } catch (error) {
    handleError(error, '音声の再生に失敗しました');
    return false;
  }
}

// 前の音声を再生
async function playPreviousAudio(currentId) {
  const sortedFiles = [...audioFiles].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
  const currentIndex = sortedFiles.findIndex(audio => audio.id === currentId);
  if (currentIndex > 0) {
    const previousAudio = sortedFiles[currentIndex - 1];
    currentAudioId = previousAudio.id;
    playAudio(previousAudio.blob);
  }
}

// 次の音声を再生
async function playNextAudio(currentId) {
  const sortedFiles = [...audioFiles].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
  const currentIndex = sortedFiles.findIndex(audio => audio.id === currentId);
  if (currentIndex >= 0 && currentIndex < sortedFiles.length - 1) {
    const nextAudio = sortedFiles[currentIndex + 1];
    currentAudioId = nextAudio.id;
    playAudio(nextAudio.blob);
  }
}

================
File: README.md
================
# Kokoro TTS Reader Chrome Extension

選択したテキストをKokoro TTSを使って音声に変換するChrome拡張機能です。

## 機能

- ウェブページ上の任意のテキストを選択して音声に変換
- コンテキストメニュー（右クリックメニュー）から簡単に実行
- Kokoro TTSのAI音声を使用した高品質な音声合成
- 設定画面でAPIキーの管理が可能

## インストール方法

1. このリポジトリをクローンまたはダウンロードします
2. Chrome拡張機能の管理ページ（`chrome://extensions/`）を開きます
3. 右上の「デベロッパーモード」をオンにします
4. 「パッケージ化されていない拡張機能を読み込む」をクリックし、クローンしたフォルダを選択します

## 使用方法

1. [fal.ai](https://fal.ai/)でアカウントを作成し、APIキーを取得します
2. 拡張機能のアイコンをクリックし、設定画面でAPIキーを入力します
3. ウェブページ上で任意のテキストを選択します
4. 右クリックして「選択テキストをKokoroTTSで読み上げ」を選択します
5. 生成された音声が自動的に再生されます

## 技術仕様

- Chrome Manifest V3を使用
- fal.aiのKokoro TTS APIを使用
- バックグラウンドワーカーとコンテンツスクリプトの連携による実装

## 必要な権限

- `contextMenus`: コンテキストメニューの作成に使用
- `storage`: APIキーの保存に使用
- `activeTab`: 現在のタブでのスクリプト実行に使用
- `scripting`: コンテンツスクリプトの動的注入に使用

## 対応URL

すべてのWebサイトで使用可能です（`<all_urls>`）。

## ライセンス

MITライセンス

## 注意事項

- この拡張機能を使用するにはfal.aiのAPIキーが必要です
- APIの利用料金は別途発生する可能性があります（fal.aiの料金プランに従います）

================
File: styles.css
================
body {
  padding: 20px;
  min-width: 800px;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  background-color: #f5f5f5;
  margin: 0;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  background: white;
  padding: 30px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.header {
  display: flex;
  align-items: center;
  margin-bottom: 30px;
  padding-bottom: 20px;
  border-bottom: 1px solid #eee;
}

.header img {
  width: 48px;
  height: 48px;
  margin-right: 15px;
}

.header h1 {
  margin: 0;
  color: #333;
  font-size: 24px;
}

.section {
  margin-bottom: 30px;
  padding: 20px;
  background: #fff;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.section-title {
  display: flex;
  align-items: center;
  margin-bottom: 20px;
  color: #333;
  font-size: 18px;
}

.section-title i {
  margin-right: 10px;
  color: #2196F3;
}

.form-group {
  margin-bottom: 20px;
}

label {
  display: block;
  margin-bottom: 8px;
  color: #555;
  font-weight: 500;
}

input[type="text"] {
  width: 100%;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 14px;
  transition: border-color 0.3s;
}

input[type="text"]:focus {
  border-color: #2196F3;
  outline: none;
  box-shadow: 0 0 0 2px rgba(33,150,243,0.1);
}

button {
  padding: 10px 20px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: 500;
  transition: background-color 0.3s;
}

.primary-button {
  background: #2196F3;
  color: white;
}

.primary-button:hover {
  background: #1976D2;
}

#status {
  margin-top: 10px;
  padding: 10px;
  border-radius: 4px;
  font-weight: 500;
}

.success {
  background: #E8F5E9;
  color: #2E7D32;
}

.error {
  background: #FFEBEE;
  color: #C62828;
}

.audio-list {
  margin-top: 20px;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 20px;
}

.audio-item {
  background: #fff;
  border-radius: 8px;
  padding: 15px;
  margin-bottom: 15px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  transition: all 0.3s ease;
  border-left: 4px solid transparent;
}

.audio-item:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.audio-item.playing {
  border-left: 4px solid #2196F3;
  background-color: #E3F2FD;
  box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);
}

.audio-text {
  font-size: 14px;
  margin-bottom: 10px;
  color: #333;
  line-height: 1.4;
}

.audio-metadata {
  font-size: 12px;
  color: #666;
  margin-bottom: 10px;
}

.metadata-row {
  display: flex;
  align-items: center;
  gap: 5px;
  margin-bottom: 4px;
}

.audio-controls {
  display: flex;
  gap: 8px;
  margin-top: 12px;
}

.audio-controls button {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 8px;
  font-size: 13px;
  border-radius: 4px;
  transition: all 0.2s ease;
}

.audio-controls button:active {
  transform: scale(0.95);
}

.audio-controls i {
  margin-right: 5px;
  font-size: 16px;
}

.play-button, .delete-button {
  display: flex;
  align-items: center;
  padding: 6px 12px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 13px;
  transition: background-color 0.2s;
}

.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px 20px;
  background-color: #f8f9fa;
  border-radius: 8px;
  text-align: center;
}

.empty-state i {
  font-size: 48px;
  color: #9e9e9e;
  margin-bottom: 16px;
}

.empty-state p {
  margin: 8px 0;
  color: #616161;
}

.empty-state-help {
  font-size: 12px;
  color: #757575;
  margin-top: 16px;
}

.play-button {
  background-color: #4CAF50;
  color: white;
}

.play-button:hover {
  background-color: #45a049;
}

.play-button:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}

.delete-button {
  background-color: #f44336;
  color: white;
}

.delete-button:hover {
  background-color: #da190b;
}

.material-icons {
  font-size: 18px;
  margin-right: 4px;
}

.empty-state {
  text-align: center;
  padding: 40px 20px;
  color: #666;
}

.empty-state i {
  font-size: 48px;
  margin-bottom: 10px;
  color: #999;
}

.loading {
  display: none;
  text-align: center;
  padding: 20px;
}

.loading.active {
  display: block;
}

.audio-list-actions {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.search-bar {
  display: flex;
  align-items: center;
  flex: 1;
  margin-right: 10px;
}

#searchInput {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 14px;
}

#searchInput:focus {
  outline: none;
  border-color: #4CAF50;
  box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.1);
}

.refresh-button, .reset-button {
  background-color: #f5f5f5;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 8px 12px;
  margin-left: 10px;
  display: flex;
  align-items: center;
  cursor: pointer;
}

.refresh-button:hover, .reset-button:hover {
  background-color: #e0e0e0;
}

.refresh-button i, .reset-button i {
  margin-right: 5px;
}

.reset-button {
  background-color: #ffebee;
  color: #c62828;
}

.reset-button:hover {
  background-color: #ffcdd2;
}

.rotating {
  animation: rotate 1.5s linear infinite;
}

.api-input-container {
  display: flex;
  gap: 10px;
  align-items: flex-end;
}

.api-input-container .form-group {
  flex: 1;
  margin-bottom: 0;
}

.api-input-container button {
  height: 40px;
  display: flex;
  align-items: center;
  gap: 5px;
}

.nav-button {
  background: #2196F3;
  color: white;
  padding: 8px;
  min-width: 40px;
}

.nav-button:hover {
  background: #1976D2;
}

.nav-button:disabled {
  background: #ccc;
  cursor: not-allowed;
}

/* Toast notifications */
.toast {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  padding: 10px 20px;
  border-radius: 4px;
  color: #fff;
  font-size: 14px;
  z-index: 10000;
  box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  animation: slideUp 0.3s ease-out;
}

.toast-info {
  background-color: #2196F3;
}

.toast-success {
  background-color: #4CAF50;
}

.toast-error {
  background-color: #f44336;
}

@keyframes slideUp {
  from {
    transform: translate(-50%, 100%);
    opacity: 0;
  }
  to {
    transform: translate(-50%, 0);
    opacity: 1;
  }
}

/* Progress bar */
.progress-bar {
  width: 100%;
  height: 4px;
  background-color: #e0e0e0;
  border-radius: 2px;
  overflow: hidden;
  margin-top: 8px;
}

.progress-bar-fill {
  height: 100%;
  background-color: #2196F3;
  transition: width 0.3s ease;
  width: 0;
}

.progress-bar.success .progress-bar-fill {
  background-color: #4CAF50;
}

.progress-bar.error .progress-bar-fill {
  background-color: #f44336;
}

@keyframes rotate {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
